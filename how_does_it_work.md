# How HyperCapslock Works

This document explains the technical implementation of the key remapping logic using Tauri and the Windows API.

## Architecture Overview

The application is split into two main layers:
1.  **UI Layer (React + TypeScript):** A lightweight web-view that displays the application status and mapping instructions.
2.  **System Layer (Rust):** A high-performance backend that interacts directly with the Windows kernel to intercept and modify keyboard input.

## The Core: Windows Low-Level Hooks

The heart of the app is a **Low-Level Keyboard Hook** (`WH_KEYBOARD_LL`). Unlike standard event listeners, this hook intercepts keyboard events at the OS level before they reach any application.

### 1. The Hook Thread
In `src-tauri/src/lib.rs`, we spawn a dedicated background thread to manage the hook. This is necessary because Windows hooks require a "Message Loop" (`GetMessage`/`DispatchMessage`) to remain active. By using a separate thread, we ensure the UI remains responsive and the remapping logic has zero latency.

### 2. Interception Logic (`low_level_keyboard_proc`)
Every keystroke on the system triggers our callback function. We handle events based on the following logic:

#### A. Preventing Feedback Loops
We check the `LLKHF_INJECTED` flag. If a key event was generated by software (like our own app), we let it pass. This prevents an infinite loop where our injected arrow keys trigger our own hook again.

#### B. CapsLock as a Modifier
To make `CapsLock` act like a "Vim Mode" trigger without breaking its original function:
- **KeyDown:** When `CapsLock` is pressed, we set a global `CAPS_DOWN` flag and **swallow** the event (preventing the OS from seeing it).
- **KeyUp:** When `CapsLock` is released, we check if any remapping occurred.
    - If you pressed `Caps + H`, we simply clear the flag.
    - If you tapped `CapsLock` alone, we manually inject a `CapsLock` press/release to toggle the state (LED light) as expected.

#### C. The Remapping Table
When `CAPS_DOWN` is active, the following transformations are applied:
- `H` → `Left Arrow`
- `J` → `Down Arrow`
- `K` → `Up Arrow`
- `L` → `Right Arrow`

The original letter keys are swallowed, and the arrow keys are injected into the system input stream using the `SendInput` API.

### 3. Shell Execution (Caps+Shift+Key)
We also check for `CapsLock` + `Shift` combinations. If a user-defined mapping exists (e.g., Key `C` -> `calc.exe`), we spawn a detached `std::process::Command` to execute the shell command. This is handled in a separate thread to prevent blocking the keyboard hook.

## Safety and Performance
- **Atomic State:** We use `AtomicBool` to track key states, ensuring thread-safe communication between the hook thread and the rest of the application.
- **Minimal Overhead:** The hook callback is written to be extremely fast. It performs simple integer comparisons and returns as quickly as possible to avoid "input lag" system-wide.
- **Native Bindings:** By using the `windows` crate, we communicate directly with `User32.dll` with zero overhead compared to a C++ implementation.
